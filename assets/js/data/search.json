[ { "title": "Stream API", "url": "/posts/Stream-API/", "categories": "Language, JAVA", "tags": "JAVA, Stream API", "date": "2022-05-20 16:50:00 +0900", "snippet": "Stream API란?Strem API 특징 Immutable(불변)하므로 원본의 데이터를 변경하지 않는다. 재사용이 불가능하다. 즉, 일회용이다. 내부 반복(internal iteration)으로 작업을 처리한다. filter-map 기반의 API를 사용하여 지연(lazy) 연산을 통해 성능을 최적화한다.1. 원본의 데이터를 변경하지 않는다.스트림은 데이터를 읽는 것이므로 원본 데이터, 즉 데이터 소스를 변경하지 않는다.스트림 연산을 통해서 아무리 데이터를 조작한다 해도 스트림에서는 데이터를 변경하지 않는다.예를 들어 아래와 같이 1 ~ 7의 정수 값이 역순으로 들어간 리스트인 list가 있다. 이 리스트를 Stream을 사용해 역순으로 정렬해 sortedList를 만들더라도 기존의 리스트의 데이터 순서는 변하지 않는 것을 확인할 수 있다.List&amp;lt;Integer&amp;gt; list = Arrays.asList(7,6,5,4,3,2,1);List&amp;lt;Integer&amp;gt; sortedList = list.stream().sorted().collect(Collectors.toList()); System.out.println(&quot;list = &quot; + list);System.out.println(&quot;sortedList = &quot; + sortedList);결과값 :list = [7, 6, 5, 4, 3, 2, 1]sortedList = [1, 2, 3, 4, 5, 6, 7]2. 일회용이다.Stream은 데이터를 모두 읽고나면 사라지게 되어 재사용이 불가능하다. 동일한 Stream이 다시 필요할 경우 다시 생성해주어야 한다.아래와 같이 Stream을 재사용하게 될 경우 IllegalStateException이 발생한다.List&amp;lt;Integer&amp;gt; list = Arrays.asList(7,6,5,4,3,2,1);Stream&amp;lt;Integer&amp;gt; stream = list.stream();int cnt = (int) stream.count();System.out.println(stream.count());결과값 :Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed ...3. 내부 반복으로 작업을 처리한다.Stream API는 메소드 내부에 반복 문법을 숨기고 있기 때문에 간결한 코드 작성이 가능하다. 즉, 기존에 사용하던 foreach와 while문을 직접 작성할 필요가 없다.List&amp;lt;Integer&amp;gt; list = Arrays.asList(1,2,3,4,5,6,7);// 기존의 방식for(int i = 0; i &amp;lt; list.size(); i++) { System.out.println(i);}// Stream API를 사용한 방식list.stream().forEach(System.out::println);Stream API 동작 흐름Stream은 크게 세가지 단계에 걸쳐 동작한다. 스트림 생성 : 스트림 생성 스트림 중간 연산 : 원본의 데이터를 별도의 데이터로 가공하는 중간 연산 스트림 최종 연산 : 가공된 데이터로 원하는 결과를 만들어내는 최종 연산1. 생성스트림 API는 다양한 데이터 소스 (컬렉션, 배열, 가변 매개변수, 난수, 람다 표현식, 파일, 빈 스트림 등)에서 생성할 수 있다.1-1. 컬렉션 Stream컬렉션 타입의 경우, 인터페이스에 추가된 default method인 stream()를 사용해 생성한다.List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);Stream&amp;lt;String&amp;gt; stream = list.stream();1-2. 배열 Stream배열 Stream은 Arrays.stream() 메서드와 Stream.of() 메서드를 사용해 생성한다.String[] arr = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;};Stream&amp;lt;String&amp;gt; arrStream = Stream.of(arr);Stream&amp;lt;String&amp;gt; arrStream = Arrays.stream(arr);Stream&amp;lt;String&amp;gt; arrStream = Arrays.stream(arr, 0, 3); // 0 ~ 2 요소 [a, b, c]1-3. 빈 Stream빈 Stream은 empty()메서드를 활용해 생성할 수 있다.Stream&amp;lt;Object&amp;gt; stream = Stream.empty();1-4. 가변 매개변수 Streamof()메서드를 활용해 가변적인 크기의 스트림을 생성할 수 있다.Stream&amp;lt;Double&amp;gt; stream = Stream.of(4.2, 2.5, 3.1, 1.9);1-5. 원시 Streamint, long, double 같은 원시 자료형을 위한 스트림이 존재한다. of() 메서드와 range()메서드를 사용해 생성할 수 있다.LongStream longStream = LongStream.of(100L);IntStream intStream = IntStream.range(1, 10);1-6. 이외이외에도 난수, 파일, 람다 표현식 스트림 등이 있다.// JAVA 8버전에서 추가된 Random 클래스를 사용한 난수 streamIntStream intStream = new Random.ints(10) // int형 난수 10개 생성 // 파일 StreamString&amp;lt;String&amp;gt; stream = Files.lines(Path path);// 람다 StreamIntStream stream = Stream.iterate(2, n -&amp;gt; n + 2); // 2, 4, 6, 8, 10, ... 중간 연산Reference https://mine-it-record.tistory.com/477 https://mangkyu.tistory.com/112?category=872426 https://pamyferret.tistory.com/43 https://gre-eny.tistory.com/191 http://www.tcpschool.com/java/java_stream_creation" }, { "title": "equals()와 hashCode()", "url": "/posts/equals()%EC%99%80-hashCode()/", "categories": "Language, JAVA", "tags": "JAVA, equals, hashCode", "date": "2022-04-21 17:44:00 +0900", "snippet": "이 포스트는 면접 과정에서 받은 “HashMap에서 키가 같은지 어떻게 판단하는가?”라는 질문에서 시작됐다. 이 질문을 받을 당시 “Map의 Key값에는 객체가 들어갈 수 도 있는데 기본 정의된 equals 메서드로는 두 객체가 같은지 판단할 수 없다”라고 생각해 제대로된 답변을 하지 못했다.이 질문에 대한 해답을 찾고자 공부한 내용을 적어본다.equals()란? 내용 비교 메서드로 해당 주소의 데이터 값을 비교하는 메서드이다. Object의 기본equals메서드는 내부적으로 == 연산(참조 비교 연산)을 해 == 과 같은 결과를 리턴한다.hashCode()란? 객체를 식별하는 하나의 정수 값으로 두 객체의 동일성을 판단한다. Object의 hashCode 메서드는 객체의 메모리 주소값을 이용해 해시값을 리턴하는 메서드이다.1. 단순비교Person이라는 객체가 있고, 이름과 나이가 같다면 동일한 객체인지 판단한다고 가정해보자.아래는 예제로 사용할 Person 클래스이다.public class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; }}이 클래스를 기반으로 이름과 나이가 동일한 p1, p2라는 객체를 만들고 equals 메서드로 비교해보자.public static void main(String[] args) { Person p1 = new Person(&quot;김자바&quot;, 27); Person p2 = new Person(&quot;김자바&quot;, 27); System.out.println(p1.equals(p2));}결과값 :false왜 결과값으로 false가 출력이 될까? 그 이유는 두 객체의 주소값이 다르기 때문이다.// Object의 기본 equals 메서드public boolean equals(Object obj) { return (this == obj);}Object 클래스의 기본 equals메서드를 살펴보면 참조 비교 연산자인 ==의 결과를 리턴한다. 다시 말해 두 객체의 주소값이 같은지를 보고 동일 객체인지 판단하게 된다. 그렇기 때문에 p1과 p2 객체를 다른 객체로 판단하는 것이다.p1, p2 두 객체를 논리적으로 같은 객체로 판단하기 위해서는 Person 클래스의 equals메서드를 재정의 해야한다.2. equals 재정의equals를 재정의 하기 위해서는 아래와 같은 규약을 반드시 지켜야 한다. 반사성(reflexivity) : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다. 대칭성(symmetry) : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true다. 추이성(transitivity) : null이 아닌 모든 참조 값 x,y,z에 대해, x.equals(y)가 true이고, y.equals(z)도 true면, x.equals(z)도 true다. 일관성(consistency) : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다. null-아님 : null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false다.예제로 사용하는 Person객체에 equals 메서드를 오버라이딩 해준다.public class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public boolean equals(Object o) { if(this == o) return true; if(!(o instanceof Person)) return false; Person person = (Person)o; return person.name.equals(this.name) &amp;amp;&amp;amp; Integer.compare(person.age, age) == 0; }}다시 p1, p2 객체를 equals 메서드로 비교해보자.public static void main(String[] args) { List&amp;lt;Person&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Person p1 = new Person(&quot;김자바&quot;, 27); Person p2 = new Person(&quot;김자바&quot;, 27); list.add(p1); list.add(p2); System.out.println(p1.equals(p2)); System.out.println(list.size());}결과값 :true2이번에는 equals를 재정의했기 때문에 처음에 구상한 조건에 맞게 이름과 나이가 같다면 같은 객체로 판단한다. List에 넣은 결과도 2로 맞게 출력이 된다.여기서 equals메서드의 값이 true인 두 객체를 HashMap에 넣어 같은 Key로 인식시키면 어떻게 될까?public static void main(String[] args) { Map&amp;lt;Person, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); Person p1 = new Person(&quot;김자바&quot;, 27); Person p2 = new Person(&quot;김자바&quot;, 27); map.put(p1, 1); map.put(p2, 1); System.out.println(map.size());}결과값 :2결과값이 2로 나온다. 두 객체가 equals메서드의 값이 true가 나와도 HashMap에서는 p1과 p2를 다른 객체로 판단한다. 이유는 무엇일까?이유는 Hash를 사용한 Collection(HashMap, HashTable, HashSet 등)은 key를 결정할때 hashCode()를 사용하기 때문이다.Collection은 객체가 논리적으로 같은지 판단하기 위해 hashCode의 return값이 일치하는지 우선 판단한다. 그 이후 equals메서드의 return값이 true라면 두 객체가 논리적으로 같다고 판단한다. 따라서 hashCode 메서드를 재정의할 필요가 있다.3. hashCode 재정의문제 해결을 위해 Person 클래스에 hashCode 메서드를 재정의해준다.아래와 같이 hashCode 메서드를 재정의해주면 nam과 age의 값을 기반으로 hash값을 생성하게된다.public class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public boolean equals(Object o) { if(this == o) return true; if(!(o instanceof Person)) return false; Person person = (Person)o; return person.name.equals(this.name) &amp;amp;&amp;amp; Integer.compare(person.age, age) == 0; } @Override public int hashCode() { return Objects.hash(name, age); }}마지막으로 p1과 p2객체를 HashMap에 넣고 size를 출력해보자public static void main(String[] args) { Map&amp;lt;Person, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); Person p1 = new Person(&quot;김자바&quot;, 27); Person p2 = new Person(&quot;김자바&quot;, 27); map.put(p1, 1); map.put(p2, 1); System.out.println(map.size());}결과값 :1Person 클래스에 주어진 조건에 맞게 equals 메서드와 hashCode를 재정의하자 HashMap에서도 두 객체가 일치한다고 판단하게 되었다. 이제 HashMap의 Key로 Person 타입을 사용할 수 있게 된다.정리 equals와 hashCode 메서드를 재정의함으로서 객체가 논리적으로 일치하는지 판단할 수 있다. 어플리케이션의 특성에 따라 다르겠지만 특수한 경우가 아니라면 equals를 재정의할 땐 hashCode도 반드시 재정의하자.Reference https://donghyeon.dev/이펙티브자바/2021/01/04/eqauls를-재정의-하는-방법/ https://tecoble.techcourse.co.kr/post/2020-07-29-equals-and-hashCode/ " } ]
